# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip
require 'fileutils'

platform :ios, '16.0'
# Update Firebase iOS SDK to a version that includes newer gRPC with stricter template fixes
# Note: v11.10.0+ carries the gRPC-Core headers with dependent-template disambiguators
$FirebaseSDKVersion = '11.10.0'
use_modular_headers!
prepare_react_native_project!

# Silence CocoaPods master specs repo warning (CDN is default)
install! 'cocoapods', :warn_for_unused_master_specs_repo => false


use_frameworks! :linkage => :static


target 'iLeafU' do
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    # Enable Fabric/New Architecture
    :fabric_enabled => true
  )

  # Constrain Firebase pods used by @react-native-firebase/* to avoid Swift 6-only APIs in v11.x
  pod 'FirebaseCore', $FirebaseSDKVersion
  pod 'FirebaseCoreInternal', $FirebaseSDKVersion
  pod 'FirebaseAuth', $FirebaseSDKVersion
  pod 'FirebaseStorage', $FirebaseSDKVersion
  pod 'FirebaseFirestore', $FirebaseSDKVersion

  target 'iLeafUTests' do
    inherit! :complete
    # Pods for testing
  end

  post_install do |installer|
    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      # :ccache_enabled => true
    )
    
    # Fix Hermes script phase to set REACT_NATIVE_PATH correctly
    begin
      react_native_path = config[:reactNativePath] || File.expand_path('../../node_modules/react-native', __dir__)
      installer.pods_project.targets.each do |target|
        if target.name == 'hermes-engine'
          target.build_phases.each do |phase|
            if phase.respond_to?(:shell_script) && phase.shell_script && phase.shell_script.include?('with-environment.sh')
              # Update the script to set REACT_NATIVE_PATH before using it
              # Use path relative to PODS_ROOT for better compatibility
              updated_script = phase.shell_script.gsub(
                /\.\s*"\$REACT_NATIVE_PATH\/scripts\/xcode\/with-environment\.sh"/,
                "REACT_NATIVE_PATH=\"$PODS_ROOT/../../node_modules/react-native\"\n        export REACT_NATIVE_PATH\n        . \"$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh\""
              )
              phase.shell_script = updated_script
              Pod::UI.puts "[post_install] Fixed REACT_NATIVE_PATH for hermes-engine script".green
            end
          end
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to fix Hermes script: #{e.message}")
    end

    # Ensure all pods use a supported minimum iOS deployment target to avoid Xcode warnings
    begin
      min_target = Gem::Version.new('12.0')
      installer.pods_project.targets.each do |t|
        t.build_configurations.each do |config|
          cur = config.build_settings['IPHONEOS_DEPLOYMENT_TARGET']
          if cur.nil? || Gem::Version.new(cur) < min_target
            config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = min_target.to_s
          end
        end
      end
      installer.pods_project.build_configurations.each do |config|
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = min_target.to_s
        # Also enable sandboxing to reduce warnings about unsandboxed script phases
        config.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'YES'
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to normalize IPHONEOS_DEPLOYMENT_TARGET/ENABLE_USER_SCRIPT_SANDBOXING: #{e.message}")
    end

    # Workaround: Some toolchains look for gRPC modulemap at Headers/Private/grpc/gRPC-Core.modulemap.
    # CocoaPods 1.15+ places modulemaps under Target Support Files. Copy it to the expected location.
    begin
      pods_root = installer.sandbox.root
      modulemap_src = File.join(pods_root, 'Target Support Files', 'gRPC-Core', 'gRPC-Core.modulemap')
      if File.exist?(modulemap_src)
        [
          File.join(pods_root, 'Headers', 'Private', 'grpc'),
          File.join(pods_root, 'Headers', 'Public', 'grpc')
        ].each do |dest_dir|
          FileUtils.mkdir_p(dest_dir) unless File.directory?(dest_dir)
          dest_path = File.join(dest_dir, 'gRPC-Core.modulemap')
          FileUtils.cp(modulemap_src, dest_path) unless File.exist?(dest_path)
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] gRPC modulemap copy failed: #{e.message}")
    end

    # Note: Do NOT set FIREBASE_BUILD_WITHOUT_SWIFT. FirebaseStorage v10 exposes Obj-C APIs
    # via a generated Swift compatibility header. Defining FIREBASE_BUILD_WITHOUT_SWIFT prevents
    # inclusion of that header and breaks FIRStorage* types for Obj-C consumers like RNFBStorage.



    # Ensure gRPC modulemap is present at build time by adding a copy phase to gRPC targets
    begin
      installer.pods_project.targets.each do |t|
        next unless ['gRPC-C++', 'gRPC-Core'].include?(t.name)
        phase_name = '[Workaround] Copy gRPC modulemap'
        exists = t.shell_script_build_phases.any? { |p| p.name == phase_name }
        unless exists
          phase = t.new_shell_script_build_phase(phase_name)
          phase.shell_script = <<-SCRIPT
PODS_ROOT="${PODS_ROOT}"
SRC="${PODS_ROOT}/Target Support Files/gRPC-Core/gRPC-Core.modulemap"
PRIV_DIR="${PODS_ROOT}/Headers/Private/grpc"
PUB_DIR="${PODS_ROOT}/Headers/Public/grpc"
mkdir -p "${PRIV_DIR}" "${PUB_DIR}"
if [ -f "${SRC}" ]; then
  cp -f "${SRC}" "${PRIV_DIR}/gRPC-Core.modulemap" || true
  cp -f "${SRC}" "${PUB_DIR}/gRPC-Core.modulemap" || true
fi
          SCRIPT
          # Ensure it runs early
          t.build_phases.move(phase, 0)
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to add gRPC modulemap copy phase: #{e.message}")
    end

    # Workaround: React Native 0.75 with modular headers can generate multiple modulemaps
    # that declare `module ReactCommon`, causing "redefinition of module 'ReactCommon'".
    # Rename the module declared in React-RuntimeApple.modulemap to avoid the collision.
    begin
      react_common_headers = File.join(installer.sandbox.root, 'Headers', 'Public', 'ReactCommon')
      rt_apple_mm = File.join(react_common_headers, 'React-RuntimeApple.modulemap')
      if File.exist?(rt_apple_mm)
        content = File.read(rt_apple_mm)
        if content =~ /^\s*module\s+ReactCommon\b/
          new_content = content.sub(/^(\s*)module\s+ReactCommon\b/, "\\1module ReactCommon_RuntimeApple")
          File.write(rt_apple_mm, new_content)
          Pod::UI.puts "[post_install] Renamed module ReactCommon in React-RuntimeApple.modulemap to ReactCommon_RuntimeApple to avoid redefinition".yellow
        end
        # Also ensure this module is not declared as an umbrella module to avoid overlapping umbrellas
        content = File.read(rt_apple_mm)
        modified = false
        if content.include?("umbrella header \"React-RuntimeApple-umbrella.h\"")
          content = content.sub(/umbrella header\s+\"React-RuntimeApple-umbrella.h\"/, 'header "React-RuntimeApple-umbrella.h"')
          modified = true
        end
        # Remove inferred submodules clause which requires an umbrella
        if content =~ /\n\s*module \* \{ export \* \ }/ || content =~ /\n\s*module \* \{ export \* \}/
          content = content.gsub(/\n\s*module \* \{ export \* \ }/, '')
          content = content.gsub(/\n\s*module \* \{ export \* \}/, '')
          modified = true
        end
        if modified
          File.write(rt_apple_mm, content)
          Pod::UI.puts "[post_install] Tweaked React-RuntimeApple.modulemap to use a non-umbrella header and removed inferred submodules".yellow
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to patch React-RuntimeApple.modulemap: #{e.message}")
    end

    # Remove incorrect weak_framework reference to FirebaseFirestoreInternal (it's a static lib, not a framework)
    begin
      support_root = File.join(installer.sandbox.root, 'Target Support Files')
      %w[Pods-iLeafU Pods-iLeafU-iLeafUTests].each do |agg|
        %w[debug release].each do |cfg|
          xc = File.join(support_root, agg, "#{agg}.#{cfg}.xcconfig")
          next unless File.exist?(xc)
          content = File.read(xc)
          patched = content.gsub(/\s-weak_framework\s+"FirebaseFirestoreInternal"/, '')
          if patched != content
            File.write(xc, patched)
            Pod::UI.puts "[post_install] Removed weak_framework FirebaseFirestoreInternal from #{agg} #{cfg} xcconfig".yellow
          end
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to remove weak_framework FirebaseFirestoreInternal: #{e.message}")
    end

    # Sanitize generated Pods project build file COMPILER_FLAGS to remove malformed -GCC_WARN_INHIBIT_ALL_WARNINGS
    # Some generated PBXBuildFile entries incorrectly include a token starting with '-G' which the clang driver
    # treats as an unsupported option for certain targets (e.g. arm64-apple-ios*-simulator). Strip that token.
    begin
      pods_project = installer.pods_project
      modified = false

      # Iterate over all PBXBuildFile objects in the generated Xcodeproj. Some build files
      # include a malformed token beginning with "-G" (for example "-GCC_WARN_INHIBIT_ALL_WARNINGS")
      # which the clang driver misinterprets as an unsupported option. Scan the project's
      # objects for PBXBuildFile entries and sanitize their COMPILER_FLAGS entries.
      pods_project.objects.each do |obj|
        next unless obj.respond_to?(:isa) && obj.isa == 'PBXBuildFile'
        if obj.respond_to?(:settings) && obj.settings && obj.settings['COMPILER_FLAGS']
          orig = obj.settings['COMPILER_FLAGS']
          cleaned = orig.dup
          # Remove the known problematic token and defensively strip any token that starts with '-G'
          cleaned = cleaned.gsub(/-GCC_WARN_INHIBIT_ALL_WARNINGS/, '')
          cleaned = cleaned.gsub(/\s*-G\S+/, '')
          cleaned = cleaned.strip
          if cleaned != orig
            obj.settings['COMPILER_FLAGS'] = cleaned
            modified = true
          end
        end
      end

      if modified
        pods_project.save
        Pod::UI.puts "[post_install] Sanitized COMPILER_FLAGS in Pods project to remove malformed -G tokens".yellow
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to sanitize COMPILER_FLAGS in Pods project: #{e.message}")
    end

    # Allow non-modular includes for pods that still use quoted/relative imports inside framework headers
    # This unblocks compilation under use_modular_headers! + use_frameworks! :linkage => :static
    begin
      non_modular_targets = [
        'RNScreens',
        'RNReanimated'
      ]
      installer.pods_project.targets.each do |t|
        next unless non_modular_targets.include?(t.name)
        t.build_configurations.each do |config|
          config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
          # Suppress quoted include warnings that often accompany these headers
          config.build_settings['CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER'] = 'NO'
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to relax non-modular include settings: #{e.message}")
    end

    # Ensure dSYM generation is enabled for all pod targets
    # This helps with crash symbolication, though pre-built frameworks like Agora may not have dSYMs
    begin
      installer.pods_project.targets.each do |t|
        t.build_configurations.each do |config|
          # Enable dSYM generation for Release builds
          if config.name == 'Release'
            config.build_settings['DEBUG_INFORMATION_FORMAT'] = 'dwarf-with-dsym'
          end
        end
      end
    rescue => e
      Pod::UI.warn("[post_install] Failed to enable dSYM generation: #{e.message}")
    end

    # Copy custom RNCSlider files to codegen output directories
    # These files are required by react-native-slider but not generated by codegen
    begin
      app_root = File.expand_path('..', __dir__)
      slider_common_dir = File.join(app_root, 'node_modules', '@react-native-community', 'slider', 'common', 'cpp', 'react', 'renderer', 'components', 'RNCSlider')
      
      # Files to copy from slider package
      files_to_copy = [
        'RNCSliderComponentDescriptor.h',
        'RNCSliderShadowNode.h',
        'RNCSliderMeasurementsManager.h',
        'RNCSliderState.h'
      ]
      
      dest_dirs = [
        File.join(app_root, 'build', 'generated', 'ios', 'react', 'renderer', 'components', 'RNCSlider'),
        File.join(app_root, 'ios', 'build', 'generated', 'ios', 'react', 'renderer', 'components', 'RNCSlider')
      ]
      
      files_to_copy.each do |filename|
        source_file = File.join(slider_common_dir, filename)
        
        if File.exist?(source_file)
          dest_dirs.each do |dest_dir|
            FileUtils.mkdir_p(dest_dir) unless File.directory?(dest_dir)
            dest_file = File.join(dest_dir, filename)
            FileUtils.cp(source_file, dest_file) if File.exist?(source_file)
          end
        end
      end
      
      # Also copy to Pods Headers/Public/React-Core for framework access
      # This ensures the files are accessible via <react/renderer/components/RNCSlider/...> imports
      pods_root = installer.sandbox.root
      react_core_public = File.join(pods_root, 'Headers', 'Public', 'React-Core')
      react_headers_dir = File.join(react_core_public, 'react', 'renderer', 'components', 'RNCSlider')
      
      # Create directory structure if it doesn't exist
      FileUtils.mkdir_p(react_headers_dir) unless File.directory?(react_headers_dir)
      
      files_to_copy.each do |filename|
        source_file = File.join(slider_common_dir, filename)
        if File.exist?(source_file)
          dest_file = File.join(react_headers_dir, filename)
          FileUtils.cp(source_file, dest_file)
        end
      end
      
      Pod::UI.puts "[post_install] Copied RNCSlider files to React-Core headers: #{react_headers_dir}".green
      
      # Add header search paths to react-native-slider target
      installer.pods_project.targets.each do |target|
        if target.name == 'react-native-slider'
          target.build_configurations.each do |config|
            header_search_paths = config.build_settings['HEADER_SEARCH_PATHS'] || []
            header_search_paths = [header_search_paths] unless header_search_paths.is_a?(Array)
            
            # Add generated directories to header search paths
            generated_dirs = [
              File.join(app_root, 'build', 'generated', 'ios'),
              File.join(app_root, 'ios', 'build', 'generated', 'ios')
            ]
            
            generated_dirs.each do |gen_dir|
              path = "\"#{gen_dir}\""
              unless header_search_paths.include?(path)
                header_search_paths << path
              end
            end
            
            config.build_settings['HEADER_SEARCH_PATHS'] = header_search_paths
          end
        end
      end
      
      # Add RNCSlider .cpp files to ReactCodegen target if they're not already included
      installer.pods_project.targets.each do |target|
        if target.name == 'ReactCodegen'
          # Find the Sources build phase
          sources_phase = target.build_phases.find { |phase| phase.is_a?(Xcodeproj::Project::Object::PBXSourcesBuildPhase) }
          
          if sources_phase
            # List of RNCSlider .cpp files to add
            rncslider_cpp_files = [
              'ComponentDescriptors.cpp',
              'EventEmitters.cpp',
              'Props.cpp',
              'ShadowNodes.cpp',
              'States.cpp'
            ]
            
            # Get the ReactCodegen group (where codegen files are organized)
            codegen_group = installer.pods_project.main_group['Pods']['ReactCodegen'] || installer.pods_project.main_group['Pods']
            
            rncslider_cpp_files.each do |filename|
              # Check if file already exists
              file_path = File.join(app_root, 'build', 'generated', 'ios', 'react', 'renderer', 'components', 'RNCSlider', filename)
              
              if File.exist?(file_path)
                # Check if file reference already exists in the project
                relative_path = "react/renderer/components/RNCSlider/#{filename}"
                file_ref = installer.pods_project.files.find { |f| f.path == relative_path }
                
                if file_ref.nil?
                  # Create file reference with absolute path
                  # Use relative path from Pods root to build/generated/ios
                  pods_root = installer.sandbox.root
                  relative_to_pods = File.join('..', '..', 'build', 'generated', 'ios', 'react', 'renderer', 'components', 'RNCSlider', filename)
                  
                  # Create file reference
                  file_ref = installer.pods_project.new_file(relative_to_pods)
                  file_ref.name = filename
                  file_ref.path = relative_to_pods
                  
                  # Add to Sources build phase
                  build_file = sources_phase.add_file_reference(file_ref)
                  build_file.settings = { 'COMPILER_FLAGS' => '-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -DFOLLY_CFG_NO_COROUTINES=1 -DFOLLY_HAVE_CLOCK_GETTIME=1 -Wno-comma -Wno-shorten-64-to-32 -Wno-documentation -Wno-nullability-completeness -std=c++20' }
                  
                  Pod::UI.puts "[post_install] Added #{filename} to ReactCodegen target".green
                end
              end
            end

            # react-native-slider also ships native C++ sources (not codegen generated) that
            # define symbols like `RNCSliderComponentName`. Ensure they are compiled too.
            slider_cpp_dir = File.join(
              app_root,
              'node_modules',
              '@react-native-community',
              'slider',
              'common',
              'cpp',
              'react',
              'renderer',
              'components',
              'RNCSlider'
            )

            slider_native_cpp_files = [
              'RNCSliderShadowNode.cpp',
              'RNCSliderMeasurementsManager.cpp' # Android-only code; harmless on iOS
            ]

            slider_native_cpp_files.each do |filename|
              abs_cpp_path = File.join(slider_cpp_dir, filename)
              next unless File.exist?(abs_cpp_path)

              relative_to_pods = File.join(
                '..',
                '..',
                'node_modules',
                '@react-native-community',
                'slider',
                'common',
                'cpp',
                'react',
                'renderer',
                'components',
                'RNCSlider',
                filename
              )

              already_added = installer.pods_project.files.any? { |f| f.path == relative_to_pods }
              next if already_added

              native_ref = installer.pods_project.new_file(relative_to_pods)
              native_ref.name = filename
              native_ref.path = relative_to_pods

              build_file = sources_phase.add_file_reference(native_ref)
              build_file.settings = { 'COMPILER_FLAGS' => '-DFOLLY_NO_CONFIG -DFOLLY_MOBILE=1 -DFOLLY_USE_LIBCPP=1 -DFOLLY_CFG_NO_COROUTINES=1 -DFOLLY_HAVE_CLOCK_GETTIME=1 -Wno-comma -Wno-shorten-64-to-32 -Wno-documentation -Wno-nullability-completeness -std=c++20' }

              Pod::UI.puts "[post_install] Added #{filename} (react-native-slider native C++) to ReactCodegen target".green
            end
            
            # Save the project to persist changes
            installer.pods_project.save
          end
        end
      end
      
      Pod::UI.puts "[post_install] Copied RNCSlider custom files and updated header search paths".green
    rescue => e
      Pod::UI.warn("[post_install] Failed to copy RNCSlider files: #{e.message}")
    end

  end
end
